<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java程序运行时内存分配详解</title>
      <link href="/2019/06/25/java-jvm20190625/"/>
      <url>/2019/06/25/java-jvm20190625/</url>
      
        <content type="html"><![CDATA[<h2 id="java程序运行时内存分配详解"><a href="#java程序运行时内存分配详解" class="headerlink" title="java程序运行时内存分配详解"></a><strong>java程序运行时内存分配详解</strong></h2><h3 id="一、-基本概念"><a href="#一、-基本概念" class="headerlink" title="一、 基本概念"></a>一、 基本概念</h3><p>​    每运行一个java程序会产生一个java进程，每个java进程可能包含一个或者多个线程，每一个Java进程对应唯一一个JVM实例，每一个JVM实例唯一对应一个堆，每一个线程有一个自己私有的栈。进程所创建的所有类的实例（也就是对象）或数组（指的是数组的本身，不是引用）都放在堆中,并由该进程所有的线程共享。Java中分配堆内存是自动初始化的，即为一个对象分配内存的时候，会初始化这个对象中变量。虽然Java中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在栈中分配,也就是说在建立一个对象时在堆和栈中都分配内存，在堆中分配的内存实际存放这个被创建的对象的本身，而在栈中分配的内存只是存放指向这个堆对象的引用而已。局部变量 new 出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。 </p><p>​    具体的概念：JVM的内存可分为3个区：<strong>堆(heap)、栈(stack)和方法区(method，也叫静态区)：</strong> </p><p><strong>堆区:</strong>  </p><p>​    1.存储的全部是对象，每个对象都包含一个与之对应的class的信息(class的目的是得到操作指令) ；</p><p>​    2.jvm只有一个堆区(heap)，且被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身和数组本身； </p><a id="more"></a><p><strong>栈区:</strong>  </p><p>​    1.每个线程包含一个栈区，栈中只保存基础数据类型本身和自定义对象的引用；</p><pre><code>2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问；3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)； </code></pre><p><strong>方法区（静态区）:</strong>  </p><p>​    1.被所有的线程共享，方法区包含所有的class（class是指类的原始代码，要创建一个类的对象，首先要把该类的代码加载到方法区中，并且初始化）和static变量。 </p><p>​     2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量。  </p><h3 id="二、实例演示"><a href="#二、实例演示" class="headerlink" title="二、实例演示"></a><strong>二、实例演示</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppMain.java </span><br><span class="line">　</span><br><span class="line">　　<span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>  <span class="title">AppMain</span>                //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的代码全部都放入方法区     </span></span><br><span class="line"><span class="class">　　</span>&#123;     </span><br><span class="line">　　<span class="function"><span class="keyword">public</span>   <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String[] args)</span>  <span class="comment">//main 方法本身放入方法区。     </span></span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　Sample test1 = <span class="keyword">new</span>  Sample( <span class="string">" 测试1 "</span> );   <span class="comment">//test1是引用，所以放到栈区里， Sample是自定义对象应该放到堆里面     </span></span><br><span class="line">　　Sample test2 = <span class="keyword">new</span>  Sample( <span class="string">" 测试2 "</span> );     </span><br><span class="line">　　   </span><br><span class="line">　　test1.printName();     </span><br><span class="line">　　test2.printName();     </span><br><span class="line">　　&#125;     </span><br><span class="line">　　&#125;     </span><br><span class="line">　　   </span><br><span class="line">　　<span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>  <span class="title">Sample</span>        //运行时, <span class="title">jvm</span> 把<span class="title">appmain</span>的信息都放入方法区     </span></span><br><span class="line"><span class="class">　　</span>&#123;     </span><br><span class="line">　　<span class="comment">/** 范例名称 */</span>     </span><br><span class="line">　　<span class="keyword">private</span> String name;      <span class="comment">//new Sample实例后， name 引用放入栈区里, name 对应的 String 对象放入堆里     </span></span><br><span class="line">　　   </span><br><span class="line">　　<span class="comment">/** 构造方法 */</span>     </span><br><span class="line">　　<span class="function"><span class="keyword">public</span>  <span class="title">Sample</span><span class="params">(String name)</span>     </span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　<span class="keyword">this</span> .name = name;     </span><br><span class="line">　　&#125;     </span><br><span class="line">　　   </span><br><span class="line">　　<span class="comment">/** 输出 */</span>     </span><br><span class="line">　　<span class="function"><span class="keyword">public</span>   <span class="keyword">void</span>  <span class="title">printName</span><span class="params">()</span>   <span class="comment">//在没有对象的时候，print方法跟随sample类被放入方法区里。     </span></span></span><br><span class="line"><span class="function">　　</span>&#123;     </span><br><span class="line">　　System.out.println(name);     </span><br><span class="line">　　&#125;     </span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/06/25/5d118fac852af36965.jpg" alt="运行时数据区"></p><p>​    运行该程序时，首先启动一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的<strong>方法区</strong>中，这就是AppMain类的加载过程。  </p><p>​    接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：  </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Sample test1=<span class="keyword">new</span> Sample(<span class="string">"测试1"</span>);</span><br></pre></td></tr></table></figure><p><strong>该语句的执行过程：</strong> </p><p>​    1、 Java虚拟机到方法区找到Sample类的类型信息，没有找到，因为Sample类还没有加载到方法区（这里可以看出，java中的内部类是单独存在的，而且刚开始的时候不会跟随包含类一起被加载，等到要用的时候才被加载）。Java虚拟机立马加载Sample类，把Sample类的类型信息存放在方法区里。 </p><pre><code>2、 Java虚拟机首先在堆区中为一个新的Sample实例分配内存, 并在Sample实例的内存中存放一个方法区中存放Sample类的类型信息的内存地址。3、 JVM的进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。4、位于“=”前的Test1是一个在main()方法中定义的一个变量（一个Sample对象的引用），因此，它被会添加到了执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例。5、JVM在堆区里继续创建另一个Sample实例，并在main方法的方法调用栈中添加一个Test2变量，该变量指向堆区中刚才创建的Sample新实例。6、JVM依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令，开始执行。 </code></pre><h3 id="三、辨析"><a href="#三、辨析" class="headerlink" title="三、辨析"></a><strong>三、辨析</strong></h3><p><strong>在Java语言里堆(heap)和栈(stack)里的区别 ：</strong></p><ol><li>栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。  　　</li><li>栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享（详见下面的介绍）。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 </li></ol><p><strong>Java中的2种数据类型：</strong> </p><p>​    一种是<strong>基本类型</strong>(primitive types), 共有8类，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。<strong>自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在</strong>。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。<strong>这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</strong> </p><p>​    栈有一个很重要的特性:存在栈中的数据可以共享。假设我们同时定义:  int a = 3;　　int b = 3;  编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，如果没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。  </p><p>​    这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与 b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p><p>​    另一种是<strong>包装类数据，</strong>如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部<strong>存在于堆中，</strong>Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。    </p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h3><pre><code>java内存分配条理还是很清楚的，如果要彻底搞懂，可以去查阅JVM相关的书籍。在java中，内存分配最让人头疼的是String对象，由于其特殊性，所以很多程序员容易搞混淆，下一篇文章再详细讲解。 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
